<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    h1 {
      font-size: 40px;
      /* display: inline-block; */
      background-color: red;
    }

    .menu {
      display: flex;
       
      background-color: yellowgreen;
    }

    .menu-link {
      background-color: blue;
      color: white; 
      margin: .1em;
      padding: .3em;
      text-decoration: none;
      /*밑줄 없애기 */
      list-style: none;
    }
    .menu-active {
      background-color: orange;
    }
  </style>
</head>

<body>
  <h1 id="main-title">   
    Event
  </h1>

  <nav class="menu">
    <a href="#" class="menu-link" data-menu="1">menu 1</a>
    <a href="#" class="menu-link" data-menu="2">menu 2</a>
    <a href="#" class="menu-link" data-menu="3">menu 3</a>
  </nav>

  <script>
    var currentMenu; // 현재 활성화 돼있는 놈을 기억시킬 장소
    var menu = document.querySelector('.menu');
    // 이벤트 핸들러 함수는 심플하게 만들어라
    // 기능별로 함수를 만들고 필요할때마다 갖다써라
    function clickHandler(e){ // event 객체가 많은 정보를 갖고 있음
      // 함수가 이벤트 핸들러로 실행됐을 때
      // 첫번째 매개변수자리에 event 객체가 자동으로 들어옴
      // 내가 클릭한 위치가 어딘지, 누굴 클릭했는지를 e가 갖고있음.
      // 만약 mousemove를 실행해주면 실시간의 위치값을 갖게 된다.
      if(currentMenu){
        currentMenu.classList.remove('menu-active');
      }
      e.target.classList.add('menu-active'); // 내가 실제로 클릭한 부분의 객체
      currentMenu = e.target;
   
      // (e.currentTarget == this)로는 내가 정확히 뭘 클릭했는지 알 수 가 없음
      // e.target(event 위임할 때 얘를 씀)
      //이벤트 위임을 써준 케이스.
      //for문을 안씀으로써 불필요한 순환을 할 필요가 없어짐
      // console.log(e.target);// target은 내가 딱 누른 그것을 가리킴
      //이벤트 위임할 때 이 target을 쓸거임
      // console.log(e);
      // console.log(e.currentTarget == this); // addEventListener를 부른 객체 지칭
      // console.log(this); //this 는 addEventListener를 호출한 객체
      // this 및 e.currentTarget는 엄마객체(menu)를 가리키지만 target은 딱 이벤트 발생한 그것을 가리킴 
      // ★★★★★★ currentTarget vs target ★★★★★★
      // 위임 장점: 특정 엘리먼트에 하나하나 이벤트를 등록 하지 않고 하나의 부모에 등록하여 부모에게 이벤트를 위임
      // 선생왈, 애드이벤트 리스너를 한 번만 쓰니 관리하기가 쉽다. 메모리도 덜 차지한다. 

      // for (var i = 0; i < menuLinks.length; i++) { // 이렇게 하나하나 이벤트 등록하면 쓸 때없이 많이 돌게 된다.
      //       menuLinks[i].addEventListener('click', clickMenuHandler);
      // }
      // -> e.target.classList.add('menu-active'); 이 한줄로써 포문 돌필요가없어짐

//무한 스크롤에대하여..!
      // ★★★1.동적인 엘리먼트에 대한 이벤트 처리가 수월하다.
      // 상위 엘리먼트에서만 이벤트 리스너를 관리하기 때문에 하위 엘리먼트는 자유롭게 추가 삭제할 수 있다.  
      // ★★★2.이벤트 핸들러 관리가 쉽다.
      // 동일한 이벤트에 대해 한 곳에서 관리하기 때문에 각각의 엘리먼트를 여러 곳에 등록하여 관리하는 것보다 관리가 수월하다.  
      // ★★★3.메모리 사용량이 줄어든다.
      // 동적으로 추가되는 이벤트가 없어지기 때문에 당연한 결과이다. 1000건의 각주를 등록한다고 생각해보면 고민할 필요로 없는 일이다.
      // ★★★4. 메모리 누수 가능성도 줄어든다.(필요하지 않은 메모리를 계속 점유한 상태) 
      // 등록 핸들러 자체가 줄어들기 때문에 메모리 누수 가능성도 줄어든다.
      //*메모리 누수 (memory漏水)
      // 컴퓨터 프로그램을 수행할 때 동적으로 할당된 메모리를 적절하게 회수하지 못하여,
      // 사용할 수 있는 메모리의 크기가 줄어드는 현상.
      

      // 페이스북으로 ex)
      // 포스트 20개 이상을 통째로 감싸고 있는 컨테이너 클릭 이벤트를 걸었다고 생각하라.  새로 추가되는 애들한테 addeventlistener를 넣어주지 않고.
      //컨테이너를 클릭했을 때 target의 값을 잡아내서 (고유 아이디) 위임
    }
    menu.addEventListener('click', clickHandler); 
    // 함수 안에서의 this는 addEventListener를 호출한 객체 menu이다.
  </script>
</body>

</html>